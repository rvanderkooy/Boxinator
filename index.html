<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Audio Effects</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }

        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 20px;
        }

        .slider-container {
            margin: 15px 0;
        }

        label {
            display: inline-block;
            width: 120px;
        }

        input[type="range"] {
            width: 200px;
        }

        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }

        .value-display {
            display: inline-block;
            margin-left: 10px;
            width: 50px;
        }

        #levelMeter {
            width: 300px;
            height: 20px;
            border: 1px solid #333;
            margin: 20px 0;
            background-color: white;
        }

        .meter-container {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin: 20px 0;
        }

        .meter-label {
            font-weight: bold;
            margin-bottom: 10px;
            display: block;
        }

        .meter-controls {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .level-meter {
            width: 300px;
            height: 20px;
            border: 1px solid #333;
            background-color: white;
        }
    </style>
</head>
<body>
    <h1>Real-time Audio Effects</h1>
    <button id="startButton" disabled>Requesting Microphone Access...</button>
    
    <div class="meter-container">
        <span class="meter-label">Input Level</span>
        <canvas id="inputLevelMeter" class="level-meter"></canvas>
        <div class="meter-controls">
            <label for="inputSensitivity">Sensitivity:</label>
            <input type="range" id="inputSensitivity" min="0.1" max="5" step="0.1" value="1">
            <span class="value-display" id="inputSensitivityValue">1x</span>
        </div>
    </div>

    <div class="meter-container">
        <span class="meter-label">Output Level</span>
        <canvas id="outputLevelMeter" class="level-meter"></canvas>
        <div class="meter-controls">
            <label for="outputSensitivity">Volume:</label>
            <input type="range" id="outputSensitivity" min="0" max="2" step="0.1" value="1">
            <span class="value-display" id="outputSensitivityValue">100%</span>
        </div>
    </div>

    <div class="controls">
        <div class="slider-container">
            <label for="inputGain">Input Gain:</label>
            <input type="range" id="inputGain" min="1" max="20" step="1" value="5">
            <span class="value-display" id="inputGainValue">5x</span>
        </div>

        <div class="slider-container">
            <label for="highpass">High-pass Filter:</label>
            <input type="range" id="highpass" min="20" max="20000" step="1" value="100">
            <span class="value-display" id="highpassValue">100Hz</span>
        </div>

        <div class="slider-container">
            <label for="delay">Delay Time:</label>
            <input type="range" id="delay" min="0" max="1" step="0.01" value="0.1">
            <span class="value-display" id="delayValue">0.1s</span>
        </div>

        <div class="slider-container">
            <label for="feedback">Delay Feedback:</label>
            <input type="range" id="feedback" min="0" max="0.9" step="0.1" value="0.2">
            <span class="value-display" id="feedbackValue">0.2</span>
        </div>
    </div>

    <div class="controls">
        <h3 style="margin-top: 0;">Ambient Effects</h3>
        <div class="slider-container">
            <label for="reverbMix">Reverb Mix:</label>
            <input type="range" id="reverbMix" min="0" max="1" step="0.01" value="0">
            <span class="value-display" id="reverbMixValue">0%</span>
        </div>

        <div class="slider-container">
            <label for="reverbTime">Reverb Time:</label>
            <input type="range" id="reverbTime" min="0.1" max="10" step="0.1" value="2">
            <span class="value-display" id="reverbTimeValue">2.0s</span>
        </div>

        <div class="slider-container">
            <label for="smoothing">Smoothing:</label>
            <input type="range" id="smoothing" min="0" max="0.99" step="0.01" value="0">
            <span class="value-display" id="smoothingValue">0%</span>
        </div>
    </div>

    <div class="controls">
        <h3 style="margin-top: 0;">Ambient Synthesizer</h3>
        <div class="slider-container">
            <label for="padVolume">Pad Volume:</label>
            <input type="range" id="padVolume" min="0" max="1" step="0.01" value="0">
            <span class="value-display" id="padVolumeValue">0%</span>
        </div>

        <div class="slider-container">
            <label for="padSensitivity">Input Sensitivity:</label>
            <input type="range" id="padSensitivity" min="0" max="5" step="0.1" value="1">
            <span class="value-display" id="padSensitivityValue">1x</span>
        </div>

        <div class="slider-container">
            <label for="padReverb">Pad Reverb:</label>
            <input type="range" id="padReverb" min="0" max="1" step="0.01" value="0">
            <span class="value-display" id="padReverbValue">0%</span>
        </div>

        <div style="margin: 15px 0;">
            <label>Pad Type:</label>
            <select id="padType" style="margin-left: 10px;">
                <option value="dream">Dreamy</option>
                <option value="major">Major Chord</option>
                <option value="minor">Minor Chord</option>
                <option value="suspended">Suspended</option>
                <option value="techno">Techno</option>
                <option value="cosmic">Cosmic</option>
                <option value="acid">Acid</option>
                <option value="ethereal">Ethereal</option>
                <option value="eastern">Eastern</option>
                <option value="space">Space</option>
                <option value="cyberpunk">Cyberpunk</option>
                <option value="synthwave">Synthwave</option>
                <option value="vaporwave">Vaporwave</option>
                <option value="future">Future Bass</option>
                <option value="glitch">Glitch</option>
            </select>
        </div>

        <div class="slider-container">
            <label for="noteVariation">Note Variation:</label>
            <input type="range" id="noteVariation" min="0" max="1" step="0.01" value="0">
            <span class="value-display" id="noteVariationValue">0%</span>
        </div>
    </div>

    <div class="controls">
        <h3 style="margin-top: 0;">Trigger Notes</h3>
        <div class="slider-container">
            <label for="triggerThreshold">Threshold:</label>
            <input type="range" id="triggerThreshold" min="0" max="0.03" step="0.001" value="0.01">
            <span class="value-display" id="triggerThresholdValue">1%</span>
        </div>

        <div class="slider-container">
            <label for="triggerVolume">Note Volume:</label>
            <input type="range" id="triggerVolume" min="0" max="1" step="0.01" value="0">
            <span class="value-display" id="triggerVolumeValue">0%</span>
        </div>

        <div class="slider-container">
            <label for="noteDuration">Note Duration:</label>
            <input type="range" id="noteDuration" min="0.1" max="2" step="0.1" value="0.5">
            <span class="value-display" id="noteDurationValue">0.5s</span>
        </div>

        <div class="slider-container">
            <label for="triggerReverb">Trigger Reverb:</label>
            <input type="range" id="triggerReverb" min="0" max="1" step="0.01" value="0">
            <span class="value-display" id="triggerReverbValue">0%</span>
        </div>

        <div class="slider-container">
            <label for="triggerDelayTime">Delay Time:</label>
            <input type="range" id="triggerDelayTime" min="0" max="2" step="0.1" value="0.3">
            <span class="value-display" id="triggerDelayTimeValue">0.3s</span>
        </div>

        <div class="slider-container">
            <label for="triggerDelayFeedback">Delay Feedback:</label>
            <input type="range" id="triggerDelayFeedback" min="0" max="1" step="0.1" value="0.4">
            <span class="value-display" id="triggerDelayFeedbackValue">40%</span>
        </div>

        <div class="slider-container">
            <label for="triggerSmoothing">Smoothing:</label>
            <input type="range" id="triggerSmoothing" min="0" max="1" step="0.01" value="0.5">
            <span class="value-display" id="triggerSmoothingValue">50%</span>
        </div>
    </div>

    <script>
        let audioContext;
        let microphone;
        let delayNode;
        let highpassFilter;
        let feedbackGain;
        let mainGainNode;
        let inputAnalyser, outputAnalyser;
        let inputCanvasContext, outputCanvasContext;
        let inputDataArray, outputDataArray;
        let inputSensitivity = 1, outputSensitivity = 1;
        let convolver, reverbGain, dryGain;
        let smoothingNode;
        let padOscillators = [];
        let padGains = [];
        let padMasterGain;
        let currentPadType = 'major';
        let noteVariationInterval;
        let baseNote = 220; // A3
        let lastTriggerTime = 0;
        let triggerThreshold = 0.3;
        let triggerCooldown = 50; // Reduced from 100ms to 50ms
        let activeNotes = new Set();

        window.addEventListener('load', async () => {
            try {
                // Initialize Audio Context first
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Check if media devices are supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Your browser does not support audio input.');
                }

                // Request microphone permission
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });
                
                // Create media stream source
                microphone = audioContext.createMediaStreamSource(stream);
                
                // Start the audio setup
                const startButton = document.getElementById('startButton');
                startButton.textContent = 'Starting Audio...';
                
                // Call the setup function
                await setupAudio();
                
                // Hide the button after successful setup
                startButton.style.display = 'none';
                
            } catch (error) {
                console.error('Detailed error:', error);
                const startButton = document.getElementById('startButton');
                
                if (error.name === 'NotAllowedError') {
                    startButton.textContent = 'Microphone Access Denied';
                    alert('Please allow microphone access and refresh the page.');
                } else if (error.name === 'NotFoundError') {
                    startButton.textContent = 'No Microphone Found';
                    alert('No microphone was found. Please connect a microphone and refresh the page.');
                } else {
                    startButton.textContent = 'Audio Setup Failed';
                    alert('Error setting up audio: ' + error.message);
                }
            }
        });

        // Move the audio setup into its own function
        async function setupAudio() {
            try {
                // Create basic audio nodes
                const inputGain = audioContext.createGain();
                highpassFilter = audioContext.createBiquadFilter();
                delayNode = audioContext.createDelay(1.0);
                feedbackGain = audioContext.createGain();
                mainGainNode = audioContext.createGain();

                // Set up analyzers
                inputAnalyser = audioContext.createAnalyser();
                outputAnalyser = audioContext.createAnalyser();
                inputAnalyser.fftSize = 256;
                outputAnalyser.fftSize = 256;
                
                inputDataArray = new Uint8Array(inputAnalyser.frequencyBinCount);
                outputDataArray = new Uint8Array(outputAnalyser.frequencyBinCount);

                // Initialize values
                inputGain.gain.value = 5;
                highpassFilter.type = 'highpass';
                highpassFilter.frequency.value = 100;
                delayNode.delayTime.value = 0.1;
                feedbackGain.gain.value = 0.2;
                mainGainNode.gain.value = 1;

                // Create ambient effect nodes
                convolver = audioContext.createConvolver();
                reverbGain = audioContext.createGain();
                dryGain = audioContext.createGain();
                smoothingNode = audioContext.createBiquadFilter();

                // Initialize ambient effects
                convolver.buffer = createReverb(2.0);
                reverbGain.gain.value = 0;
                dryGain.gain.value = 1;
                smoothingNode.type = 'lowpass';
                smoothingNode.frequency.value = 20000;

                // Modified audio routing to include all effects
                microphone
                    .connect(inputAnalyser)
                    .connect(inputGain)
                    .connect(smoothingNode)
                    .connect(highpassFilter);

                highpassFilter.connect(dryGain);
                highpassFilter.connect(convolver);
                convolver.connect(reverbGain);

                highpassFilter.connect(delayNode);
                delayNode.connect(feedbackGain);
                feedbackGain.connect(delayNode);
                delayNode.connect(mainGainNode);

                dryGain.connect(mainGainNode);
                reverbGain.connect(mainGainNode);

                mainGainNode.connect(outputAnalyser);
                outputAnalyser.connect(audioContext.destination);

                // Set default pad type to Dreamy
                document.getElementById('padType').value = 'dream';
                currentPadType = 'dream';

                // Initialize pad synthesizer with default values
                createPadOscillators();

                // Set default pad volume to 7%
                document.getElementById('padVolume').value = 0.07;
                document.getElementById('padVolumeValue').textContent = '7%';
                padMasterGain.gain.value = 0.07;

                // Set default trigger note volume to 20%
                document.getElementById('triggerVolume').value = 0.2;
                document.getElementById('triggerVolumeValue').textContent = '20%';

                // Add this: Set default note variation to 10%
                document.getElementById('noteVariation').value = 0.1;
                document.getElementById('noteVariationValue').textContent = '10%';

                // Set up visualizers
                const inputCanvas = document.getElementById('inputLevelMeter');
                const outputCanvas = document.getElementById('outputLevelMeter');
                inputCanvas.width = outputCanvas.width = 300;
                inputCanvas.height = outputCanvas.height = 20;
                inputCanvasContext = inputCanvas.getContext('2d');
                outputCanvasContext = outputCanvas.getContext('2d');

                // Start the meters
                drawLevelMeters();

                // Initialize all controls
                setupControls();
                setupAmbientControls();
                setupPadControls();
                setupTriggerControls();

            } catch (error) {
                console.error('Error setting up audio:', error);
                throw error;
            }
        }

        function createReverb(duration) {
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * duration;
            const impulse = audioContext.createBuffer(2, length, sampleRate);
            
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    const decay = Math.exp(-i / (sampleRate * duration / 6));
                    channelData[i] = (Math.random() * 2 - 1) * decay;
                }
            }
            return impulse;
        }

        function makeDistortionCurve(amount) {
            const samples = 44100;
            const curve = new Float32Array(samples);
            const deg = Math.PI / 180;

            for (let i = 0; i < samples; ++i) {
                const x = (i * 2) / samples - 1;
                curve[i] = (3 + amount) * x * 20 * deg / (Math.PI + amount * Math.abs(x));
            }
            return curve;
        }

        function setupControls() {
            // Input sensitivity control
            document.getElementById('inputSensitivity').addEventListener('input', (e) => {
                inputSensitivity = parseFloat(e.target.value);
                document.getElementById('inputSensitivityValue').textContent = `${inputSensitivity}x`;
            });

            // Output sensitivity control
            document.getElementById('outputSensitivity').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                outputSensitivity = value;
                mainGainNode.gain.value = value;
                document.getElementById('outputSensitivityValue').textContent = `${Math.round(value * 100)}%`;
            });

            // Delay control
            document.getElementById('delay').addEventListener('input', (e) => {
                delayNode.delayTime.value = e.target.value;
                document.getElementById('delayValue').textContent = `${e.target.value}s`;
            });

            // Feedback control
            document.getElementById('feedback').addEventListener('input', (e) => {
                feedbackGain.gain.value = e.target.value;
                document.getElementById('feedbackValue').textContent = e.target.value;
            });

            // Highpass filter control
            document.getElementById('highpass').addEventListener('input', (e) => {
                highpassFilter.frequency.value = e.target.value;
                document.getElementById('highpassValue').textContent = `${e.target.value}Hz`;
            });
        }

        function drawLevelMeters() {
            requestAnimationFrame(drawLevelMeters);

            // Draw input meter
            inputAnalyser.getByteFrequencyData(inputDataArray);
            const inputAverage = inputDataArray.reduce((a, b) => a + b) / inputDataArray.length;
            const inputLevel = Math.min(inputAverage / 256 * inputSensitivity, 1);

            // Draw meters
            drawMeter(inputCanvasContext, inputLevel);
            
            // Output meter
            outputAnalyser.getByteFrequencyData(outputDataArray);
            const outputAverage = outputDataArray.reduce((a, b) => a + b) / outputDataArray.length;
            const outputLevel = Math.min(outputAverage / 256 * outputSensitivity, 1);
            drawMeter(outputCanvasContext, outputLevel);
        }

        function drawMeter(context, level) {
            // Clear canvas
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, 300, 20);

            // Draw level meter
            const gradient = context.createLinearGradient(0, 0, 300, 0);
            gradient.addColorStop(0, '#4CAF50');    // Green
            gradient.addColorStop(0.6, '#ffeb3b');  // Yellow
            gradient.addColorStop(1, '#f44336');    // Red

            context.fillStyle = gradient;
            context.fillRect(0, 0, 300 * level, 20);
        }

        function setupAmbientControls() {
            // Reverb mix control
            document.getElementById('reverbMix').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                reverbGain.gain.value = value;
                dryGain.gain.value = 1 - value;
                document.getElementById('reverbMixValue').textContent = `${Math.round(value * 100)}%`;
            });

            // Reverb time control
            document.getElementById('reverbTime').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                convolver.buffer = createReverb(value);
                document.getElementById('reverbTimeValue').textContent = `${value.toFixed(1)}s`;
            });

            // Smoothing control
            document.getElementById('smoothing').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                const frequency = 20000 * (1 - value);
                smoothingNode.frequency.value = Math.max(20, frequency);
                document.getElementById('smoothingValue').textContent = `${Math.round(value * 100)}%`;
            });
        }

        function createPadOscillators() {
            // Clean up any existing oscillators and intervals
            padOscillators.forEach(osc => osc.stop());
            if (noteVariationInterval) {
                clearInterval(noteVariationInterval);
            }
            padOscillators = [];
            padGains = [];

            // Create pad master gain
            padMasterGain = audioContext.createGain();
            padMasterGain.gain.value = 0;

            // Define scales for different pad types
            const scales = {
                major: [0, 2, 4, 5, 7, 9, 11, 12, 14, 16],     // Traditional major
                minor: [0, 2, 3, 5, 7, 8, 10, 12, 14, 15],     // Natural minor
                suspended: [0, 2, 5, 7, 9, 12, 14, 17],         // Suspended
                dream: [0, 2, 4, 7, 9, 12, 14, 16, 19],        // Dreamy
                techno: [0, 1, 5, 7, 8, 12, 13, 17, 19],       // Techno-inspired
                cosmic: [0, 4, 7, 11, 14, 17, 21, 24],         // Wide cosmic intervals
                acid: [0, 3, 7, 10, 13, 15, 19, 22],           // Acid-style
                ethereal: [0, 2, 5, 7, 9, 12, 14, 17, 21],     // Ethereal/ambient
                eastern: [0, 1, 4, 5, 7, 8, 11, 12, 13, 16],   // Eastern-inspired
                space: [0, 4, 8, 10, 14, 18, 22, 26],           // Wide space intervals
                cyberpunk: [0, 1, 4, 7, 8, 11, 13, 16, 19],
                synthwave: [0, 4, 7, 11, 14, 16, 19, 23],
                vaporwave: [0, 3, 7, 10, 12, 15, 19, 24],
                future: [0, 2, 4, 7, 9, 11, 14, 16, 19],
                glitch: [0, 1, 6, 7, 13, 14, 19, 20]
            };

            // Define base chords for different pad types
            const chordIntervals = {
                major: [0, 4, 7, 12],          // Major chord
                minor: [0, 3, 7, 12],          // Minor chord
                suspended: [0, 5, 7, 12],       // Suspended chord
                dream: [0, 4, 7, 11],          // Dreamy chord
                techno: [0, 5, 7, 10],         // Techno chord
                cosmic: [0, 4, 8, 11],         // Cosmic chord
                acid: [0, 3, 6, 10],           // Acid chord
                ethereal: [0, 5, 9, 15],       // Ethereal chord
                eastern: [0, 4, 7, 13],        // Eastern chord
                space: [0, 4, 8, 12, 16],       // Space chord
                cyberpunk: [0, 4, 8, 11, 15],
                synthwave: [0, 4, 7, 11, 16],
                vaporwave: [0, 3, 7, 10, 14],
                future: [0, 4, 7, 11, 14],
                glitch: [0, 6, 13, 19]
            };

            // Modify the oscillator creation to include different waveforms per pad type
            function createOscillatorsForIntervals(intervals) {
                const waveforms = {
                    techno: ['sawtooth', 'square'],
                    acid: ['sawtooth', 'sawtooth'],
                    cosmic: ['sine', 'triangle'],
                    ethereal: ['sine', 'sine'],
                    space: ['sine', 'triangle'],
                    eastern: ['triangle', 'sine'],
                    dream: ['sine', 'triangle'],
                    major: ['sine', 'triangle'],
                    minor: ['sine', 'triangle'],
                    suspended: ['sine', 'triangle'],
                    cyberpunk: ['sawtooth', 'square'],
                    synthwave: ['sawtooth', 'triangle'],
                    vaporwave: ['triangle', 'sine'],
                    future: ['square', 'triangle'],
                    glitch: ['square', 'sawtooth']
                };

                intervals.forEach(interval => {
                    // Create two oscillators per note for richer sound
                    for (let i = 0; i < 2; i++) {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        
                        const freq = baseNote * Math.pow(2, interval / 12);
                        osc.frequency.value = freq * (1 + i * 0.001);
                        
                        // Use specific waveforms for each pad type
                        osc.type = waveforms[currentPadType][i];
                        
                        osc.connect(gain);
                        gain.connect(padMasterGain);
                        gain.gain.value = currentPadType === 'acid' ? 0.15 : 0.2; // Lower gain for acid type
                        
                        osc.start();
                        padOscillators.push(osc);
                        padGains.push(gain);
                    }
                });
            }

            // Initial chord creation
            createOscillatorsForIntervals(chordIntervals[currentPadType]);

            // Set up note variation
            const variationSpeed = 2000; // 2 seconds between variations
            noteVariationInterval = setInterval(() => {
                const variationAmount = parseFloat(document.getElementById('noteVariation').value);
                if (variationAmount > 0) {
                    // Get the current scale
                    const currentScale = scales[currentPadType];
                    
                    // Different variation patterns
                    const patterns = [
                        // Ascending pattern
                        (index) => currentScale[index % currentScale.length],
                        // Descending pattern
                        (index) => currentScale[currentScale.length - 1 - (index % currentScale.length)],
                        // Alternating pattern
                        (index) => currentScale[(index * 2) % currentScale.length],
                        // Random jumps
                        () => currentScale[Math.floor(Math.random() * currentScale.length)],
                        // Clustered notes
                        (index) => {
                            const center = Math.floor(Math.random() * currentScale.length);
                            const offset = Math.floor(Math.random() * 3) - 1;
                            return currentScale[(center + offset + currentScale.length) % currentScale.length];
                        }
                    ];

                    // Randomly select a pattern every few variations
                    if (Math.random() < 0.3) { // 30% chance to change pattern
                        currentPattern = Math.floor(Math.random() * patterns.length);
                    }

                    // Apply the current pattern
                    padOscillators.forEach((osc, index) => {
                        if (Math.random() < variationAmount) {
                            const pattern = patterns[currentPattern];
                            const newNote = pattern(index);
                            const newFreq = baseNote * Math.pow(2, newNote / 12);
                            
                            // Add slight random timing variation
                            const randomDelay = Math.random() * 0.2;
                            
                            // Smooth transition to new frequency with random timing
                            osc.frequency.setTargetAtTime(
                                newFreq * (1 + (index % 2) * 0.001),
                                audioContext.currentTime + randomDelay,
                                0.2
                            );
                        }
                    });
                }
            }, variationSpeed);

            padMasterGain.connect(mainGainNode);
        }

        function setupPadControls() {
            // Pad volume control
            document.getElementById('padVolume').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                padMasterGain.gain.value = value;
                document.getElementById('padVolumeValue').textContent = `${Math.round(value * 100)}%`;
            });

            // Add this pad sensitivity control
            document.getElementById('padSensitivity').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('padSensitivityValue').textContent = `${value.toFixed(1)}x`;
            });

            // Add this for the pad reverb control
            document.getElementById('padReverb').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                reverbGain.gain.value = value;
                document.getElementById('padReverbValue').textContent = `${Math.round(value * 100)}%`;
            });

            // Pad type selector
            document.getElementById('padType').addEventListener('change', (e) => {
                currentPadType = e.target.value;
                createPadOscillators();
                
                // Automatically set pad volume to 7% when type changes
                document.getElementById('padVolume').value = 0.07;
                document.getElementById('padVolumeValue').textContent = '7%';
                padMasterGain.gain.value = 0.07;
            });

            // Update the drawLevelMeters function to modulate the pad
            const originalDrawLevelMeters = drawLevelMeters;
            drawLevelMeters = function() {
                originalDrawLevelMeters();

                // Get input level and use it to modulate pad sounds
                const inputLevel = inputDataArray.reduce((a, b) => a + b) / inputDataArray.length / 256;
                const sensitivity = parseFloat(document.getElementById('padSensitivity').value);
                
                // Modulate each pad oscillator's gain
                padGains.forEach((gain, i) => {
                    const modAmount = inputLevel * sensitivity * 0.5;
                    const baseGain = 0.2;
                    gain.gain.setTargetAtTime(
                        baseGain + modAmount,
                        audioContext.currentTime,
                        0.1
                    );
                });
            };

            // Add note variation control
            document.getElementById('noteVariation').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('noteVariationValue').textContent = `${Math.round(value * 100)}%`;
            });
        }

        function setupTriggerControls() {
            document.getElementById('triggerThreshold').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                triggerThreshold = value;
                document.getElementById('triggerThresholdValue').textContent = `${(value * 100).toFixed(2)}%`;
            });

            document.getElementById('triggerVolume').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('triggerVolumeValue').textContent = `${Math.round(value * 100)}%`;
            });

            document.getElementById('noteDuration').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('noteDurationValue').textContent = `${value}s`;
            });

            // Add this for the trigger reverb control
            document.getElementById('triggerReverb').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                noteReverbGain.gain.value = value; // Adjust this line based on your reverb setup
                document.getElementById('triggerReverbValue').textContent = `${Math.round(value * 100)}%`;
            });

            // Add this for the trigger delay time control
            document.getElementById('triggerDelayTime').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                noteDelay.delayTime.value = value; // Adjust the delay time
                document.getElementById('triggerDelayTimeValue').textContent = `${value}s`;
            });

            // Add this for the trigger delay feedback control
            document.getElementById('triggerDelayFeedback').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                delayFeedback.gain.value = value; // Adjust the feedback gain
                document.getElementById('triggerDelayFeedbackValue').textContent = `${Math.round(value * 100)}%`;
            });

            document.getElementById('triggerSmoothing').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('triggerSmoothingValue').textContent = `${Math.round(value * 100)}%`;
            });
        }

        function createTriggeredNote(frequency) {
            const oscillators = [];
            const gains = [];
            
            // Create effect nodes
            const masterGain = audioContext.createGain();
            const noteDelay = audioContext.createDelay(2.0); // Create a new delay node for each note
            const delayFeedback = audioContext.createGain();
            const noteReverb = audioContext.createConvolver();
            const reverbGain = audioContext.createGain();

            // Configure effects
            noteDelay.delayTime.value = parseFloat(document.getElementById('triggerDelayTime').value); // Use the slider value
            delayFeedback.gain.value = parseFloat(document.getElementById('triggerDelayFeedback').value); // Use the slider value
            reverbGain.gain.value = parseFloat(document.getElementById('triggerReverb').value); // Use the slider value

            // Create reverb impulse
            noteReverb.buffer = createReverb(2.0); // 2 second reverb

            const noteLength = parseFloat(document.getElementById('noteDuration').value);
            const volume = parseFloat(document.getElementById('triggerVolume').value);

            // Create richer oscillator combination
            const oscillatorTypes = [
                { type: 'sine', volume: 1.0 },
                { type: 'triangle', volume: 0.5 },
                { type: 'sine', volume: 0.3, detune: 7 },
                { type: 'sine', volume: 0.3, detune: -7 },
                { type: 'triangle', volume: 0.2, detune: 3 },
                { type: 'sine', volume: 0.15, octave: 1 }
            ];

            oscillatorTypes.forEach(({ type, volume: oscVolume, detune = 0, octave = 0 }) => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = type;
                osc.frequency.value = frequency * Math.pow(2, octave);
                if (detune) osc.detune.value = detune;

                gain.gain.value = oscVolume * volume; // Set gain based on volume

                // Connect each oscillator through the delay and reverb
                osc.connect(gain);
                gain.connect(noteDelay); // Connect to delay
                gain.connect(noteReverb); // Connect to reverb
                noteReverb.connect(reverbGain); // Connect reverb to output
                noteDelay.connect(delayFeedback); // Connect delay feedback
                delayFeedback.connect(noteDelay); // Feedback loop
                noteDelay.connect(masterGain); // Connect delay to master gain
                reverbGain.connect(masterGain); // Connect reverb to master gain
                
                oscillators.push(osc);
                gains.push(gain);
            });

            // Set up audio routing
            masterGain.connect(mainGainNode); // Connect master gain to main output

            // Start all oscillators
            oscillators.forEach(osc => {
                osc.start();
                osc.stop(audioContext.currentTime + noteLength); // Stop after note length
            });

            // Clean up
            oscillators[0].onended = () => {
                [masterGain, noteDelay, delayFeedback, noteReverb, reverbGain].forEach(node => {
                    node.disconnect();
                });
                oscillators.forEach(osc => osc.disconnect());
                gains.forEach(gain => gain.disconnect());
                activeNotes.delete(oscillators[0]);
            };

            activeNotes.add(oscillators[0]);
        }

        // Update the drawLevelMeters function to include trigger detection
        const originalDrawLevelMeters = drawLevelMeters;
        drawLevelMeters = function() {
            originalDrawLevelMeters();

            // Get the frequency data for click detection
            const frequencyData = new Uint8Array(inputAnalyser.frequencyBinCount);
            inputAnalyser.getByteFrequencyData(frequencyData);

            // Focus on high frequencies (clicks have more high-frequency content)
            const highFreqStart = Math.floor(frequencyData.length * 0.7); // Look at top 30% of frequencies
            const highFreqEnd = frequencyData.length;
            
            // Calculate high-frequency energy
            let highFreqEnergy = 0;
            for (let i = highFreqStart; i < highFreqEnd; i++) {
                highFreqEnergy += frequencyData[i];
            }
            highFreqEnergy /= (highFreqEnd - highFreqStart);
            
            // Normalize to 0-1 range
            const clickLevel = highFreqEnergy / 256;

            const threshold = parseFloat(document.getElementById('triggerThreshold').value);
            const now = Date.now();

            // Detect sudden increases in high-frequency energy
            if (clickLevel > threshold && now - lastTriggerTime > triggerCooldown) {
                // Get current scale based on pad type
                const scales = {
                    major: [0, 2, 4, 5, 7, 9, 11, 12, 14, 16],
                    minor: [0, 2, 3, 5, 7, 8, 10, 12, 14, 15],
                    suspended: [0, 2, 5, 7, 9, 12, 14, 17],
                    dream: [0, 2, 4, 7, 9, 12, 14, 16, 19]
                };

                const currentScale = scales[currentPadType];
                
                // Choose a random note from the scale
                const randomNote = currentScale[Math.floor(Math.random() * currentScale.length)];
                const noteFreq = baseNote * Math.pow(2, randomNote / 12);

                createTriggeredNote(noteFreq);
                lastTriggerTime = now;
            }
        };
    </script>
</body>
</html>
