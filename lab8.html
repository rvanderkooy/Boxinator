<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Thud Counter (Mic Listener)</title>
    <style>
        :root {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        }

        body {
            margin: 24px;
            max-width: 900px;
        }

        h1 {
            margin: 0 0 8px;
        }

        .row {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 10px 14px;
            font-size: 14px;
            cursor: pointer;
        }

        .card {
            border: 1px solid #ddd;
            border-radius: 12px;
            padding: 16px;
            margin-top: 16px;
            box-shadow: 0 1px 8px rgba(0,0,0,0.06);
        }

        .stat {
            font-size: 40px;
            font-weight: 700;
            line-height: 1;
        }

        .muted {
            color: #555;
        }

        label {
            display: block;
            font-weight: 600;
            margin-top: 10px;
        }

        input[type="range"] {
            width: 320px;
            max-width: 90vw;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        @media (max-width: 720px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .meterWrap {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .meter {
            width: 420px;
            max-width: 90vw;
            height: 14px;
            border-radius: 999px;
            background: #eee;
            overflow: hidden;
            border: 1px solid #ddd;
        }

        .bar {
            height: 100%;
            width: 0%;
            background: #2b7;
            transition: width 60ms linear;
        }

        .pill {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 999px;
            background: #f3f3f3;
            border: 1px solid #ddd;
        }

        #log {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>
    <h1>Thud Counter</h1>
    <div class="muted">
        Click <b>Start</b>, allow microphone access, then it will detect sudden “thud” impacts (tunable).
    </div>

    <div class="row" style="margin-top:12px;">
        <button id="btnUnlockSounds">Unlock Sounds</button>
        <button id="btnStart">Start</button>
        <button id="btnStop" disabled>Stop</button>
        <button id="btnReset" disabled>Reset Count</button>
        <span class="pill" id="status">Idle</span>
    </div>

    <div class="card grid">
        <div>
            <div class="muted">Thuds detected</div>
            <div class="stat" id="count">0</div>

            <div style="margin-top:14px;" class="meterWrap">
                <div class="meter"><div class="bar" id="bar"></div></div>
                <span class="pill" id="levelText">level: 0.000</span>
            </div>

            <div class="muted" style="margin-top:10px;">
                Detection uses: (1) sudden volume increase, (2) low-frequency energy, (3) cooldown to avoid double counts.
                <div style="margin-top:6px;">
                    <b>Pro mode (iPhone Safari):</b> actual thud trigger runs in an <b>AudioWorklet</b> (or ScriptProcessor fallback)
                    to catch the impact earlier than the UI/RAF loop. The analyser loop remains for meter + confirm.
                </div>
            </div>
        </div>

        <div>
            <div class="muted" style="margin-bottom:8px;">Tuning</div>

            <label>
                Sensitivity (Volume Spike Threshold): <span id="thrVal"></span>
            </label>
            <input id="thr" type="range" min="0.01" max="0.40" step="0.005" value="0.10" />

            <label>
                Low-Freq Bias (0 = off, 1 = strict thud): <span id="lfVal"></span>
            </label>
            <input id="lf" type="range" min="0" max="1" step="0.05" value="0.55" />

            <label>
                Cooldown (ms, prevents double counting): <span id="cdVal"></span>
            </label>
            <input id="cd" type="range" min="100" max="2000" step="50" value="450" />

            <label>
                Noise Floor Adaptation (higher = adapts faster): <span id="nfVal"></span>
            </label>
            <input id="nf" type="range" min="0.001" max="0.08" step="0.001" value="0.010" />

            <label>
                3-Thud Combo Window (ms): <span id="comboVal"></span>
            </label>
            <input id="combo" type="range" min="200" max="2000" step="50" value="650" />

            <div class="muted" style="margin-top:10px;">
                Tip: If it misses thuds, lower threshold a bit. If it false-triggers, raise threshold and/or increase low-freq bias.
                <div style="margin-top:6px;">
                    Combo tip: lower window = harder to trigger (must be faster). higher window = easier to trigger.
                </div>
            </div>
        </div>
    </div>

    <div class="card">
        <div class="row" style="justify-content: space-between;">
            <div class="muted">Event log (latest first)</div>
            <button id="btnClearLog" disabled>Clear Log</button>
        </div>
        <div id="log" style="margin-top:10px;"></div>
    </div>

    <script>
        // ---- UI ----
        const $ = (id) => document.getElementById(id);

        const btnUnlockSounds = $("btnUnlockSounds");
        const btnStart = $("btnStart");
        const btnStop = $("btnStop");
        const btnReset = $("btnReset");
        const btnClearLog = $("btnClearLog");

        const statusEl = $("status");
        const countEl = $("count");
        const barEl = $("bar");
        const levelTextEl = $("levelText");
        const logEl = $("log");

        const thr = $("thr"), lf = $("lf"), cd = $("cd"), nf = $("nf"), combo = $("combo");
        const thrVal = $("thrVal"), lfVal = $("lfVal"), cdVal = $("cdVal"), nfVal = $("nfVal"), comboVal = $("comboVal");

        function syncLabels() {
            thrVal.textContent = Number(thr.value).toFixed(3);
            lfVal.textContent = Number(lf.value).toFixed(2);
            cdVal.textContent = `${Number(cd.value).toFixed(0)}`;
            nfVal.textContent = Number(nf.value).toFixed(3);
            comboVal.textContent = `${Number(combo.value).toFixed(0)}`;
        }
        [thr, lf, cd, nf, combo].forEach(el => el.addEventListener("input", syncLabels));
        syncLabels();

        function setStatus(text) { statusEl.textContent = text; }

        function addLog(line) {
            const now = new Date();
            const ts = now.toLocaleTimeString();
            const current = logEl.textContent.trim();
            const next = `[${ts}] ${line}\n` + (current ? current + "\n" : "");
            logEl.textContent = next.split("\n").slice(0, 80).join("\n"); // keep last ~80 lines
        }

        // ---- Audio / Mic ----
        let audioCtx = null;
        let stream = null;
        let source = null;

        // We keep analyser strictly for meter + optional confirm (not primary triggering)
        let analyser = null;
        let filterLow = null;
        let rafId = null;

        let thudCount = 0;

        // Meter baseline
        let baseline = 0.02;
        let lastLevel = 0;

        // ---- Low-latency sound buffers (Web Audio) ----
        let explosion3Buffer = null;
        let explosion3Gain = null;
        let explosion3FetchPromise = null;

        let explosion5Buffer = null;
        let explosion5Gain = null;
        let explosion5FetchPromise = null;

        // pools so rapid hits don't cut each other off
        const EXPLOSION3_VOICES = 5;
        const EXPLOSION5_VOICES = 3;

        let voice3Index = 0;
        let voice5Index = 0;

        let voice3Pool = [];
        let voice5Pool = [];

        async function loadBuffer(url) {
            const res = await fetch(url, { cache: "force-cache" });
            if (!res.ok) {
                throw new Error(`Fetch failed (${res.status}) for ${new URL(url, location.href).href}`);
            }
            const arr = await res.arrayBuffer();
            return await audioCtx.decodeAudioData(arr);
        }

        async function loadExplosion3() {
            if (!audioCtx) throw new Error("audioCtx not initialized yet");
            if (explosion3Buffer) return explosion3Buffer;
            if (explosion3FetchPromise) return explosion3FetchPromise;

            explosion3FetchPromise = (async () => {
                explosion3Buffer = await loadBuffer("assets/explosion3.mp3");

                explosion3Gain = audioCtx.createGain();
                explosion3Gain.gain.value = 1.0;
                explosion3Gain.connect(audioCtx.destination);

                voice3Pool = new Array(EXPLOSION3_VOICES).fill(null);
                return explosion3Buffer;
            })();

            return explosion3FetchPromise;
        }

        async function loadExplosion5() {
            if (!audioCtx) throw new Error("audioCtx not initialized yet");
            if (explosion5Buffer) return explosion5Buffer;
            if (explosion5FetchPromise) return explosion5FetchPromise;

            explosion5FetchPromise = (async () => {
                explosion5Buffer = await loadBuffer("assets/explosion5.mp3");

                explosion5Gain = audioCtx.createGain();
                explosion5Gain.gain.value = 1.0;
                explosion5Gain.connect(audioCtx.destination);

                voice5Pool = new Array(EXPLOSION5_VOICES).fill(null);
                return explosion5Buffer;
            })();

            return explosion5FetchPromise;
        }

        function playExplosion3Now({ quietStart = false } = {}) {
            if (!audioCtx || !explosion3Buffer || !explosion3Gain) return;

            const src = audioCtx.createBufferSource();
            src.buffer = explosion3Buffer;
            src.connect(explosion3Gain);

            if (quietStart) {
                const t = audioCtx.currentTime;
                explosion3Gain.gain.cancelScheduledValues(t);
                explosion3Gain.gain.setValueAtTime(0.05, t);
            }

            src.start(audioCtx.currentTime);

            voice3Pool[voice3Index] = src;
            voice3Index = (voice3Index + 1) % EXPLOSION3_VOICES;
        }

        function playExplosion5Now() {
            if (!audioCtx || !explosion5Buffer || !explosion5Gain) return;

            const src = audioCtx.createBufferSource();
            src.buffer = explosion5Buffer;
            src.connect(explosion5Gain);

            // For combo, always full
            const t = audioCtx.currentTime;
            explosion5Gain.gain.cancelScheduledValues(t);
            explosion5Gain.gain.setValueAtTime(1.0, t);

            src.start(audioCtx.currentTime);

            voice5Pool[voice5Index] = src;
            voice5Index = (voice5Index + 1) % EXPLOSION5_VOICES;
        }

        function rampExplosion3Gain(target, seconds) {
            if (!audioCtx || !explosion3Gain) return;
            const t = audioCtx.currentTime;
            explosion3Gain.gain.cancelScheduledValues(t);
            explosion3Gain.gain.setValueAtTime(explosion3Gain.gain.value, t);
            explosion3Gain.gain.linearRampToValueAtTime(target, t + seconds);
        }

        // ---- 3-thud combo detector ----
        // Tracks recent EARLY triggers; if 3 happen within combo window -> play explosion5
        let recentThudsMs = [];
        let lastComboAtMs = 0;

        function registerThudForCombo(nowMs) {
            const windowMs = Number(combo.value);

            recentThudsMs.push(nowMs);

            // keep only within window
            recentThudsMs = recentThudsMs.filter(t => (nowMs - t) <= windowMs);

            // simple guard so combos don't spam if you keep hitting
            const comboGuardMs = Math.max(250, Math.floor(windowMs / 2));
            const canCombo = (nowMs - lastComboAtMs) > comboGuardMs;

            if (canCombo && recentThudsMs.length >= 3) {
                lastComboAtMs = nowMs;
                recentThudsMs = []; // reset after combo

                playExplosion5Now();
                addLog(`COMBO x3! Played explosion5 (window=${windowMs}ms)`);
            }
        }

        // ---- Pro detection (AudioWorklet preferred, ScriptProcessor fallback) ----
        let thudNode = null;               // AudioWorkletNode or ScriptProcessorNode
        let workletReady = false;

        let pendingThud = false;           // early trigger fired; awaiting confirm window
        let confirmDeadlineMs = 0;

        const CONFIRM_WINDOW_MS = 60;      // confirm within this time after early trigger
        const EARLY_COOLDOWN_MS = 250;     // prevents repeated early triggers
        let lastEarlyAtMs = 0;

        async function setupThudWorkletOrFallback() {
            if (!audioCtx) throw new Error("audioCtx missing");

            // Prefer AudioWorklet when available
            if (audioCtx.audioWorklet && !workletReady) {
                const workletCode = `
class ThudDetector extends AudioWorkletProcessor {
          constructor() {
            super();

            // Envelope + baseline
            this.env = 0;
            this.base = 0.02;
            this.lastEnv = 0;

            // Low-frequency proxy (one-pole lowpass)
            this.lp = 0;

            // Parameters
            this.thr = 0.10;
            this.lfBias = 0.55;
            this.nfAdapt = 0.010;
            this.cooldownMs = 250;

            this.lastTriggerMs = 0;

            this.port.onmessage = (e) => {
              const d = e.data || {};
              if (d.type === "PARAMS") {
                if (typeof d.thr === "number") this.thr = d.thr;
                if (typeof d.lf === "number") this.lfBias = d.lf;
                if (typeof d.nf === "number") this.nfAdapt = d.nf;
                if (typeof d.cooldownMs === "number") this.cooldownMs = d.cooldownMs;
              }
            };
          }

          process(inputs) {
            const input = inputs[0];
            if (!input || input.length === 0) return true;

            const ch0 = input[0];
            if (!ch0) return true;

            const adapt = this.nfAdapt;

            // Rough one-pole lowpass around ~180Hz
            const alpha = Math.exp(-2 * Math.PI * 180 / sampleRate);

            let envSum = 0;
            let lpAbs = 0;
            let fullAbs = 0;

            for (let i = 0; i < ch0.length; i++) {
              const x = ch0[i];
              const ax = Math.abs(x);

              envSum += ax;

              this.lp = alpha * this.lp + (1 - alpha) * x;
              lpAbs += Math.abs(this.lp);
              fullAbs += ax;
            }

            const env = envSum / ch0.length;

            // Adaptive baseline
            this.base = (1 - adapt) * this.base + adapt * env;

            const spike = env - this.base;
            const onset = env - this.lastEnv;
            this.lastEnv = env;

            const ratio = fullAbs > 0 ? (lpAbs / fullAbs) : 0;

            // Early trigger (FAST)
            const onsetMin = 0.010 + this.thr * 0.08;
            const early =
              spike > (this.thr * 0.65) &&
              onset > (onsetMin * 0.65);

            const nowMs = currentTime * 1000;

            if (early && (nowMs - this.lastTriggerMs) > this.cooldownMs) {
              this.lastTriggerMs = nowMs;

              const ratioMin = 0.10 + this.lfBias * 0.20;

              this.port.postMessage({ type: "EARLY", spike, onset, ratio, ratioMin });

              // If already clearly LF-heavy, send confirm immediately
              if (ratio > ratioMin) {
                this.port.postMessage({ type: "CONFIRM", ratio });
              } else {
                this.port.postMessage({ type: "NEED_CONFIRM", ratio, ratioMin });
              }
            }

            return true;
          }
}
registerProcessor("thud-detector", ThudDetector);
`;
                const blob = new Blob([workletCode], { type: "application/javascript" });
                const url = URL.createObjectURL(blob);
                await audioCtx.audioWorklet.addModule(url);
                URL.revokeObjectURL(url);

                thudNode = new AudioWorkletNode(audioCtx, "thud-detector");
                thudNode.port.onmessage = (e) => handleThudWorkletMessage(e.data);

                // Must connect the node for it to run; keep silent via zero-gain
                const zero = audioCtx.createGain();
                zero.gain.value = 0;
                thudNode.connect(zero).connect(audioCtx.destination);

                workletReady = true;
                return;
            }

            // Fallback: ScriptProcessorNode (deprecated but still works widely)
            const bufferSize = 256; // smaller = earlier detection (more CPU)
            const sp = audioCtx.createScriptProcessor(bufferSize, 1, 1);
            sp.onaudioprocess = (ev) => {
                const ch0 = ev.inputBuffer.getChannelData(0);
                handleThudSamplesFallback(ch0, audioCtx.sampleRate);
            };

            const zero = audioCtx.createGain();
            zero.gain.value = 0;
            sp.connect(zero).connect(audioCtx.destination);
            thudNode = sp;
        }

        function pushParamsToDetector() {
            const payload = {
                type: "PARAMS",
                thr: Number(thr.value),
                lf: Number(lf.value),
                nf: Number(nf.value),
                cooldownMs: Math.max(EARLY_COOLDOWN_MS, Number(cd.value)) // keep sane
            };
            if (thudNode && thudNode.port) {
                thudNode.port.postMessage(payload);
            }
            // ScriptProcessor fallback reads sliders directly in handler (no-op here)
        }
        [thr, lf, cd, nf].forEach(el => el.addEventListener("input", pushParamsToDetector));

        function handleThudWorkletMessage(msg) {
            const nowMs = performance.now();

            if (msg?.type === "EARLY") {
                if (nowMs - lastEarlyAtMs < EARLY_COOLDOWN_MS) return;
                lastEarlyAtMs = nowMs;

                // register for combo FIRST so combo can layer on top
                registerThudForCombo(nowMs);

                pendingThud = true;
                confirmDeadlineMs = nowMs + CONFIRM_WINDOW_MS;

                // EARLY: start instantly at low volume
                playExplosion3Now({ quietStart: true });

                // Count + log on EARLY (feels best)
                thudCount++;
                countEl.textContent = String(thudCount);
                addLog(`THUD(EARLY) #${thudCount} spike=${Number(msg.spike).toFixed(3)} onset=${Number(msg.onset).toFixed(3)} ratio≈${Number(msg.ratio).toFixed(2)}`);

                return;
            }

            if (msg?.type === "CONFIRM") {
                if (!pendingThud) return;
                // CONFIRM: ramp to full quickly
                rampExplosion3Gain(1.0, 0.02);
                pendingThud = false;
                addLog(`THUD(CONFIRM worklet) ratio≈${Number(msg.ratio).toFixed(2)}`);
                return;
            }

            // NEED_CONFIRM: do nothing here; analyser loop will confirm within window if enabled
        }

        // ScriptProcessor fallback detector (fast envelope + lowpass ratio proxy)
        // (Used only if AudioWorklet isn't available)
        let fb_base = 0.02;
        let fb_lastEnv = 0;
        let fb_lp = 0;
        let fb_lastTriggerMs = 0;

        function handleThudSamplesFallback(samples, sampleRate) {
            // Read sliders live (main-thread)
            const thrV = Number(thr.value);
            const lfV = Number(lf.value);
            const nfV = Number(nf.value);
            const cooldownMs = Math.max(EARLY_COOLDOWN_MS, Number(cd.value));

            const alpha = Math.exp(-2 * Math.PI * 180 / sampleRate);

            let envSum = 0;
            let lpAbs = 0;
            let fullAbs = 0;

            for (let i = 0; i < samples.length; i++) {
                const x = samples[i];
                const ax = Math.abs(x);
                envSum += ax;

                fb_lp = alpha * fb_lp + (1 - alpha) * x;
                lpAbs += Math.abs(fb_lp);
                fullAbs += ax;
            }

            const env = envSum / samples.length;
            fb_base = (1 - nfV) * fb_base + nfV * env;

            const spike = env - fb_base;
            const onset = env - fb_lastEnv;
            fb_lastEnv = env;

            const onsetMin = 0.010 + thrV * 0.08;
            const early =
                spike > (thrV * 0.65) &&
                onset > (onsetMin * 0.65);

            const ratio = fullAbs > 0 ? (lpAbs / fullAbs) : 0;
            const ratioMin = 0.10 + lfV * 0.20;

            const nowMs = performance.now();

            if (early && (nowMs - fb_lastTriggerMs) > cooldownMs) {
                fb_lastTriggerMs = nowMs;

                if (nowMs - lastEarlyAtMs >= EARLY_COOLDOWN_MS) {
                    lastEarlyAtMs = nowMs;

                    registerThudForCombo(nowMs);

                    pendingThud = true;
                    confirmDeadlineMs = nowMs + CONFIRM_WINDOW_MS;

                    playExplosion3Now({ quietStart: true });

                    thudCount++;
                    countEl.textContent = String(thudCount);
                    addLog(`THUD(EARLY fallback) #${thudCount} spike=${spike.toFixed(3)} onset=${onset.toFixed(3)} ratio≈${ratio.toFixed(2)}`);

                    if (ratio > ratioMin) {
                        rampExplosion3Gain(1.0, 0.02);
                        pendingThud = false;
                        addLog(`THUD(CONFIRM fallback) ratio≈${ratio.toFixed(2)}`);
                    }
                }
            }
        }

        // ---- Analyser helpers (meter + optional confirm) ----
        function computeRms(timeData) {
            let sum = 0;
            for (let i = 0; i < timeData.length; i++) {
                const v = (timeData[i] - 128) / 128;
                sum += v * v;
            }
            return Math.sqrt(sum / timeData.length);
        }

        function computeLowFreqRatio(freqData, sampleRate, fftSize) {
            const nyquist = sampleRate / 2;
            const binHz = nyquist / (freqData.length);
            const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));

            const loStart = 20, loEnd = 160;
            const hiEnd = 1000;

            const loA = clamp(Math.floor(loStart / binHz), 0, freqData.length - 1);
            const loB = clamp(Math.floor(loEnd / binHz), 0, freqData.length - 1);
            const hiB = clamp(Math.floor(hiEnd / binHz), 0, freqData.length - 1);

            let low = 0, total = 0;
            for (let i = loA; i <= hiB; i++) {
                const mag = freqData[i] / 255;
                const e = mag * mag;
                total += e;
                if (i >= loA && i <= loB) low += e;
            }
            return total > 0 ? (low / total) : 0;
        }

        function updateMeter(level) {
            const pct = Math.max(0, Math.min(100, (level / 0.35) * 100));
            barEl.style.width = pct.toFixed(1) + "%";
            levelTextEl.textContent = `level: ${level.toFixed(3)}  (base: ${baseline.toFixed(3)})`;
        }

        function detectLoop() {
            if (!analyser) return;

            const timeData = new Uint8Array(analyser.fftSize);
            const freqData = new Uint8Array(analyser.frequencyBinCount);

            analyser.getByteTimeDomainData(timeData);
            analyser.getByteFrequencyData(freqData);

            const level = computeRms(timeData);

            // Baseline for meter only
            const adapt = Number(nf.value);
            baseline = (1 - adapt) * baseline + adapt * level;

            updateMeter(level);

            // Optional confirm window:
            if (pendingThud) {
                const nowMs = performance.now();
                if (nowMs > confirmDeadlineMs) {
                    // Not confirmed: fade down so false positives are softer.
                    rampExplosion3Gain(0.05, 0.03);
                    pendingThud = false;
                    addLog("THUD(NO CONFIRM) faded down");
                } else {
                    const ratio = computeLowFreqRatio(freqData, audioCtx.sampleRate, analyser.fftSize);
                    const ratioMin = 0.08 + (Number(lf.value) * 0.22);
                    if (ratio > ratioMin) {
                        rampExplosion3Gain(1.0, 0.02);
                        pendingThud = false;
                        addLog(`THUD(CONFIRM main) ratio=${ratio.toFixed(2)}`);
                    }
                }
            }

            lastLevel = level;
            rafId = requestAnimationFrame(detectLoop);
        }

        async function unlockSounds() {
            try {
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state !== "running") await audioCtx.resume();

                await Promise.all([loadExplosion3(), loadExplosion5()]);

                // prime output path with an inaudible tick
                const tick = audioCtx.createBufferSource();
                const buf = audioCtx.createBuffer(1, 1, audioCtx.sampleRate);
                tick.buffer = buf;
                tick.connect(audioCtx.destination);
                tick.start();

                setStatus("Sounds unlocked");
                addLog("Sounds unlocked + explosions preloaded (3 + 5).");
            } catch (e) {
                console.error(e);
                addLog(`ERROR unlocking sounds: ${e?.message || e}`);
            }
        }

        async function start() {
            try {
                setStatus("Requesting mic access…");

                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state !== "running") await audioCtx.resume();

                // Setup pro detector (AudioWorklet preferred)
                await setupThudWorkletOrFallback();
                pushParamsToDetector();

                // Try preload explosions now as well (still a user gesture)
                try { await Promise.all([loadExplosion3(), loadExplosion5()]); } catch (e) { addLog(`WARN: preload failed: ${e?.message || e}`); }

                stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        // You can reduce latency further by disabling these,
                        // but leaving your original values as requested.
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: false
                    }
                });

                source = audioCtx.createMediaStreamSource(stream);

                // Connect mic to detector node (runs on audio thread when worklet is used)
                if (thudNode) {
                    source.connect(thudNode);
                }

                // Keep analyser for meter + confirm
                filterLow = audioCtx.createBiquadFilter();
                filterLow.type = "lowpass";
                filterLow.frequency.value = 220;

                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 1024; // smaller window helps confirm quickly
                analyser.smoothingTimeConstant = 0.08;

                source.connect(filterLow);
                filterLow.connect(analyser);

                baseline = 0.02;
                lastLevel = 0;
                pendingThud = false;
                recentThudsMs = [];
                lastComboAtMs = 0;

                setStatus("Listening");
                addLog("Listening started.");

                btnStart.disabled = true;
                btnStop.disabled = false;
                btnReset.disabled = false;
                btnClearLog.disabled = false;

                detectLoop();
            } catch (err) {
                console.error(err);
                setStatus("Mic permission denied / error");

                const details = `${err?.name || "Error"}: ${err?.message || err}`;
                addLog(`ERROR: ${details}`);

                await stop();
            }
        }

        async function stop() {
            if (rafId) cancelAnimationFrame(rafId);
            rafId = null;

            if (analyser) { try { analyser.disconnect(); } catch { } }
            if (filterLow) { try { filterLow.disconnect(); } catch { } }
            if (source) { try { source.disconnect(); } catch { } }

            analyser = null;
            filterLow = null;
            source = null;

            if (thudNode) {
                try { thudNode.disconnect(); } catch { }
            }

            if (stream) {
                stream.getTracks().forEach(t => t.stop());
                stream = null;
            }

            // Keep AudioContext warm for low-latency playback
            if (audioCtx) {
                try { await audioCtx.suspend(); } catch { }
            }

            btnStart.disabled = false;
            btnStop.disabled = true;
            btnReset.disabled = false;
            btnClearLog.disabled = false;

            setStatus("Stopped");
            addLog("Listening stopped.");
            updateMeter(0);

            pendingThud = false;
            recentThudsMs = [];
        }

        function resetCount() {
            thudCount = 0;
            countEl.textContent = "0";
            addLog("Count reset.");
        }

        function clearLog() {
            logEl.textContent = "";
        }

        btnUnlockSounds.addEventListener("click", unlockSounds);
        btnStart.addEventListener("click", start);
        btnStop.addEventListener("click", stop);
        btnReset.addEventListener("click", resetCount);
        btnClearLog.addEventListener("click", clearLog);

        // Stop mic when tab is hidden (only if we actually have a stream)
        document.addEventListener("visibilitychange", () => {
            if (document.hidden && stream) stop();
        });
    </script>
</body>
</html>
